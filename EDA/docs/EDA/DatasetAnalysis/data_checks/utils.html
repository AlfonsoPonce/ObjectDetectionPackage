<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>EDA.DatasetAnalysis.data_checks.utils API documentation</title>
<meta name="description" content="This module serves some utilities for every operation involved in data checking â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EDA.DatasetAnalysis.data_checks.utils</code></h1>
</header>
<section id="section-intro">
<p>This module serves some utilities for every operation involved in data checking.</p>
<p>Author: Alfonso Ponce Navarro</p>
<p>Date: 08/11/2023</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
This module serves some utilities for every operation involved in data checking.

Author: Alfonso Ponce Navarro

Date: 08/11/2023
&#39;&#39;&#39;
import os
from pathlib import Path
from PIL import Image, ImageChops
import numpy as np
from tqdm import tqdm
import logging
import time
from multiprocessing import Pool, Queue, Manager
import math

IMAGE_EXTENSION_LIST = [&#39;.png&#39;, &#39;.jpg&#39;, &#39;.jpeg&#39;]
LABEL_EXTENSION_LIST = [&#39;.xml&#39;, &#39;.json&#39;, &#39;.txt&#39;]

def check_label_extensions(labels_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks label extensions inside labels folder.

    :param labels_dir: labels folder.
    :return: Number of files per available extension (available extensions: xml (PASCAL VOC), json(COCO), txt(YOLO)).
    &#39;&#39;&#39;
    try:
        assert labels_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{labels_dir} not found.&#34;)
        raise err

    extension_dict = {&#39;.xml&#39;: 0, &#39;.json&#39;: 0, &#39;.txt&#39;: 0}
    for extension in LABEL_EXTENSION_LIST:
        extension_dict[extension] = len(list(labels_dir.glob(f&#39;*{extension}&#39;)))

    return extension_dict


def check_images_extensions(images_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks images extensions inside images folder.

    :param images_dir: images folder.
    :return: Number of files per available extension (available extensions: png, jpg, jpeg).
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    extension_dict = {&#39;.png&#39;: 0, &#39;.jpg&#39;: 0, &#39;.jpeg&#39;: 0}
    for extension in IMAGE_EXTENSION_LIST:
        extension_dict[extension] = len(list(images_dir.glob(f&#39;*{extension}&#39;)))

    return extension_dict

def check_corrupted_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Checks the number of corrupted images inside images folder.

    :param images_dir: images folder.
    :return: list of corrupted images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err


    corrupted_file_list = []
    for extension in IMAGE_EXTENSION_LIST:
        for image_file in images_dir.glob(f&#39;*{extension}&#39;):
            try:
                im = Image.open(str(image_file))
                im.verify()  # I perform also verify, don&#39;t know if he sees other types o defects
                im.close()  # reload is necessary in my case
                im = Image.open(str(image_file))
                im.transpose(Image.FLIP_LEFT_RIGHT)
                im.close()
            except:
                corrupted_file_list.append(image_file.name)
                logging.warning(f&#34;Found corrupted image {image_file.name}&#34;)

    return corrupted_file_list

def check_unpaired_entities(images_dir: Path, labels_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks if all images have their labels and viceversa. Images and labels MUST be named the same (e.g.:1.jpg --&gt; 1.xml).

    :param images_dir: images folder path.
    :param labels_dir: labels folder path.
    :return: Images without labels and labels without images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    try:
        assert labels_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{labels_dir} not found.&#34;)
        raise err

    unpaired_entities_dict = {&#39;images_wo_labels&#39;: [], &#39;labels_wo_images&#39;: []}


    image_list = []
    label_list = []

    for image_extension in IMAGE_EXTENSION_LIST:
        image_list.extend(list(images_dir.glob(f&#39;*{image_extension}&#39;)))
        for label_extension in LABEL_EXTENSION_LIST:
            label_list.extend(list(labels_dir.glob(f&#39;*{label_extension}&#39;)))

    image_set = set([file.stem for file in image_list])
    labels_set = set([file.stem for file in label_list])

    unpaired_entities_dict[&#39;images_wo_labels&#39;] = image_set.difference_update(labels_set)
    unpaired_entities_dict[&#39;labels_wo_images&#39;] = labels_set.difference_update(image_set)

    return unpaired_entities_dict


def check_duplicated_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset.

    :param images_dir: images folder path.
    :return: List of pairs whose pairs contain duplicated images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    duplicate_images_list = []

    for extension in IMAGE_EXTENSION_LIST:
        img_files = list(images_dir.glob(f&#39;*{extension}&#39;))

        for img_idx in tqdm(range(len(img_files))):
            img = Image.open(str(img_files[img_idx])).convert(&#39;RGB&#39;)
            img_idx_to_remove = img_idx + 1

            ini = time.time()
            while img_idx_to_remove &lt; len(img_files):
                img_to_remove = Image.open(str(img_files[img_idx_to_remove])).convert(&#39;RGB&#39;)
                diff = ImageChops.difference(img, img_to_remove)

                if not diff.getbbox(): #If not different images
                    duplicate_images_list.append((img_files[img_idx].name, img_files[img_idx_to_remove].name))

                img_idx_to_remove += 1
            print(f&#34;Tiempo transcurrido: {ini - time.time()}&#34;)

    return duplicate_images_list



def compute_kernel(img_idx_list: list, img_files: list, result_queue: Queue) -&gt; None:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset in parallel.

    :param img_idx_list: list of image indexes to process.
    :param img_files: list of all images.
    :param result_queue: Common queue for all processes to put the results in.
    &#39;&#39;&#39;
    duplicate_images_list = []
    for img_idx in tqdm(img_idx_list):
        img = Image.open(str(img_files[img_idx])).convert(&#39;RGB&#39;)
        img_idx_to_remove = img_idx + 1

        while img_idx_to_remove &lt; len(img_files):
            img_to_remove = Image.open(str(img_files[img_idx_to_remove])).convert(&#39;RGB&#39;)
            diff = ImageChops.difference(img, img_to_remove)

            if not diff.getbbox():  # If not different images
                duplicate_images_list.append((img_files[img_idx].name, img_files[img_idx_to_remove].name))

            img_idx_to_remove += 1


    result_queue.put(duplicate_images_list)

def parallel_check_duplicated_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset in parallel.

    :param images_dir: images folder path.
    :return: List of pairs whose pairs contain duplicated images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err
    num_processes = int(os.cpu_count())
    pool = Pool(processes=num_processes)
    manager = Manager()
    results_queue = manager.Queue()
    #for extension in IMAGE_EXTENSION_LIST:
    img_files = list(images_dir.glob(f&#39;*&#39;))
    num_instances = len(img_files)
    if num_instances != 0:
        img_idxs = list(range(num_instances))

        lim_inf = 0
        lim_sup = math.ceil(num_instances / num_processes)
        batch = lim_sup

        for i in range(num_processes):
            pool.apply_async(compute_kernel, (img_idxs[lim_inf:lim_sup],img_files, i, results_queue))
            lim_inf = lim_sup

            if lim_sup &gt; num_instances:
                lim_sup = num_instances-1
            else:
                lim_sup += batch
    pool.close()
    pool.join()

    duplicated_images = []

    while not results_queue.empty():
        duplicated_images.extend(results_queue.get())

    return duplicated_images




def get_images_shapes(images_dir: Path) -&gt; set:
    &#39;&#39;&#39;
    Get all image shapes in dataset.

    :param images_dir:  images folder
    :return: All shapes in dataset
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    shape_list = []
    for extension in IMAGE_EXTENSION_LIST:
        image_list = list(images_dir.glob(f&#39;*{extension}&#39;))
        shape_list.extend([np.array(Image.open(str(image))).shape for image in image_list])

    return set(shape_list)



if __name__ == &#39;__main__&#39;:
    print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="EDA.DatasetAnalysis.data_checks.utils.check_corrupted_images"><code class="name flex">
<span>def <span class="ident">check_corrupted_images</span></span>(<span>images_dir:Â pathlib.Path) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the number of corrupted images inside images folder.</p>
<p>:param images_dir: images folder.
:return: list of corrupted images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_corrupted_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Checks the number of corrupted images inside images folder.

    :param images_dir: images folder.
    :return: list of corrupted images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err


    corrupted_file_list = []
    for extension in IMAGE_EXTENSION_LIST:
        for image_file in images_dir.glob(f&#39;*{extension}&#39;):
            try:
                im = Image.open(str(image_file))
                im.verify()  # I perform also verify, don&#39;t know if he sees other types o defects
                im.close()  # reload is necessary in my case
                im = Image.open(str(image_file))
                im.transpose(Image.FLIP_LEFT_RIGHT)
                im.close()
            except:
                corrupted_file_list.append(image_file.name)
                logging.warning(f&#34;Found corrupted image {image_file.name}&#34;)

    return corrupted_file_list</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.check_duplicated_images"><code class="name flex">
<span>def <span class="ident">check_duplicated_images</span></span>(<span>images_dir:Â pathlib.Path) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Gets duplicated images in a dataset.</p>
<p>:param images_dir: images folder path.
:return: List of pairs whose pairs contain duplicated images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_duplicated_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset.

    :param images_dir: images folder path.
    :return: List of pairs whose pairs contain duplicated images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    duplicate_images_list = []

    for extension in IMAGE_EXTENSION_LIST:
        img_files = list(images_dir.glob(f&#39;*{extension}&#39;))

        for img_idx in tqdm(range(len(img_files))):
            img = Image.open(str(img_files[img_idx])).convert(&#39;RGB&#39;)
            img_idx_to_remove = img_idx + 1

            ini = time.time()
            while img_idx_to_remove &lt; len(img_files):
                img_to_remove = Image.open(str(img_files[img_idx_to_remove])).convert(&#39;RGB&#39;)
                diff = ImageChops.difference(img, img_to_remove)

                if not diff.getbbox(): #If not different images
                    duplicate_images_list.append((img_files[img_idx].name, img_files[img_idx_to_remove].name))

                img_idx_to_remove += 1
            print(f&#34;Tiempo transcurrido: {ini - time.time()}&#34;)

    return duplicate_images_list</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.check_images_extensions"><code class="name flex">
<span>def <span class="ident">check_images_extensions</span></span>(<span>images_dir:Â pathlib.Path) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Checks images extensions inside images folder.</p>
<p>:param images_dir: images folder.
:return: Number of files per available extension (available extensions: png, jpg, jpeg).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_images_extensions(images_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks images extensions inside images folder.

    :param images_dir: images folder.
    :return: Number of files per available extension (available extensions: png, jpg, jpeg).
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    extension_dict = {&#39;.png&#39;: 0, &#39;.jpg&#39;: 0, &#39;.jpeg&#39;: 0}
    for extension in IMAGE_EXTENSION_LIST:
        extension_dict[extension] = len(list(images_dir.glob(f&#39;*{extension}&#39;)))

    return extension_dict</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.check_label_extensions"><code class="name flex">
<span>def <span class="ident">check_label_extensions</span></span>(<span>labels_dir:Â pathlib.Path) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Checks label extensions inside labels folder.</p>
<p>:param labels_dir: labels folder.
:return: Number of files per available extension (available extensions: xml (PASCAL VOC), json(COCO), txt(YOLO)).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_label_extensions(labels_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks label extensions inside labels folder.

    :param labels_dir: labels folder.
    :return: Number of files per available extension (available extensions: xml (PASCAL VOC), json(COCO), txt(YOLO)).
    &#39;&#39;&#39;
    try:
        assert labels_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{labels_dir} not found.&#34;)
        raise err

    extension_dict = {&#39;.xml&#39;: 0, &#39;.json&#39;: 0, &#39;.txt&#39;: 0}
    for extension in LABEL_EXTENSION_LIST:
        extension_dict[extension] = len(list(labels_dir.glob(f&#39;*{extension}&#39;)))

    return extension_dict</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.check_unpaired_entities"><code class="name flex">
<span>def <span class="ident">check_unpaired_entities</span></span>(<span>images_dir:Â pathlib.Path, labels_dir:Â pathlib.Path) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if all images have their labels and viceversa. Images and labels MUST be named the same (e.g.:1.jpg &ndash;&gt; 1.xml).</p>
<p>:param images_dir: images folder path.
:param labels_dir: labels folder path.
:return: Images without labels and labels without images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_unpaired_entities(images_dir: Path, labels_dir: Path) -&gt; dict:
    &#39;&#39;&#39;
    Checks if all images have their labels and viceversa. Images and labels MUST be named the same (e.g.:1.jpg --&gt; 1.xml).

    :param images_dir: images folder path.
    :param labels_dir: labels folder path.
    :return: Images without labels and labels without images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    try:
        assert labels_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{labels_dir} not found.&#34;)
        raise err

    unpaired_entities_dict = {&#39;images_wo_labels&#39;: [], &#39;labels_wo_images&#39;: []}


    image_list = []
    label_list = []

    for image_extension in IMAGE_EXTENSION_LIST:
        image_list.extend(list(images_dir.glob(f&#39;*{image_extension}&#39;)))
        for label_extension in LABEL_EXTENSION_LIST:
            label_list.extend(list(labels_dir.glob(f&#39;*{label_extension}&#39;)))

    image_set = set([file.stem for file in image_list])
    labels_set = set([file.stem for file in label_list])

    unpaired_entities_dict[&#39;images_wo_labels&#39;] = image_set.difference_update(labels_set)
    unpaired_entities_dict[&#39;labels_wo_images&#39;] = labels_set.difference_update(image_set)

    return unpaired_entities_dict</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.compute_kernel"><code class="name flex">
<span>def <span class="ident">compute_kernel</span></span>(<span>img_idx_list:Â list, img_files:Â list, result_queue:Â <boundÂ methodÂ BaseContext.QueueÂ ofÂ <multiprocessing.context.DefaultContextÂ objectÂ atÂ 0x0000026FFEEE00D0>>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Gets duplicated images in a dataset in parallel.</p>
<p>:param img_idx_list: list of image indexes to process.
:param img_files: list of all images.
:param result_queue: Common queue for all processes to put the results in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_kernel(img_idx_list: list, img_files: list, result_queue: Queue) -&gt; None:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset in parallel.

    :param img_idx_list: list of image indexes to process.
    :param img_files: list of all images.
    :param result_queue: Common queue for all processes to put the results in.
    &#39;&#39;&#39;
    duplicate_images_list = []
    for img_idx in tqdm(img_idx_list):
        img = Image.open(str(img_files[img_idx])).convert(&#39;RGB&#39;)
        img_idx_to_remove = img_idx + 1

        while img_idx_to_remove &lt; len(img_files):
            img_to_remove = Image.open(str(img_files[img_idx_to_remove])).convert(&#39;RGB&#39;)
            diff = ImageChops.difference(img, img_to_remove)

            if not diff.getbbox():  # If not different images
                duplicate_images_list.append((img_files[img_idx].name, img_files[img_idx_to_remove].name))

            img_idx_to_remove += 1


    result_queue.put(duplicate_images_list)</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.get_images_shapes"><code class="name flex">
<span>def <span class="ident">get_images_shapes</span></span>(<span>images_dir:Â pathlib.Path) â€‘>Â set</span>
</code></dt>
<dd>
<div class="desc"><p>Get all image shapes in dataset.</p>
<p>:param images_dir:
images folder
:return: All shapes in dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images_shapes(images_dir: Path) -&gt; set:
    &#39;&#39;&#39;
    Get all image shapes in dataset.

    :param images_dir:  images folder
    :return: All shapes in dataset
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err

    shape_list = []
    for extension in IMAGE_EXTENSION_LIST:
        image_list = list(images_dir.glob(f&#39;*{extension}&#39;))
        shape_list.extend([np.array(Image.open(str(image))).shape for image in image_list])

    return set(shape_list)</code></pre>
</details>
</dd>
<dt id="EDA.DatasetAnalysis.data_checks.utils.parallel_check_duplicated_images"><code class="name flex">
<span>def <span class="ident">parallel_check_duplicated_images</span></span>(<span>images_dir:Â pathlib.Path) â€‘>Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Gets duplicated images in a dataset in parallel.</p>
<p>:param images_dir: images folder path.
:return: List of pairs whose pairs contain duplicated images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallel_check_duplicated_images(images_dir: Path) -&gt; list:
    &#39;&#39;&#39;
    Gets duplicated images in a dataset in parallel.

    :param images_dir: images folder path.
    :return: List of pairs whose pairs contain duplicated images.
    &#39;&#39;&#39;
    try:
        assert images_dir.exists()
    except AssertionError as err:
        logging.error(f&#34;{images_dir} not found.&#34;)
        raise err
    num_processes = int(os.cpu_count())
    pool = Pool(processes=num_processes)
    manager = Manager()
    results_queue = manager.Queue()
    #for extension in IMAGE_EXTENSION_LIST:
    img_files = list(images_dir.glob(f&#39;*&#39;))
    num_instances = len(img_files)
    if num_instances != 0:
        img_idxs = list(range(num_instances))

        lim_inf = 0
        lim_sup = math.ceil(num_instances / num_processes)
        batch = lim_sup

        for i in range(num_processes):
            pool.apply_async(compute_kernel, (img_idxs[lim_inf:lim_sup],img_files, i, results_queue))
            lim_inf = lim_sup

            if lim_sup &gt; num_instances:
                lim_sup = num_instances-1
            else:
                lim_sup += batch
    pool.close()
    pool.join()

    duplicated_images = []

    while not results_queue.empty():
        duplicated_images.extend(results_queue.get())

    return duplicated_images</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EDA.DatasetAnalysis.data_checks" href="index.html">EDA.DatasetAnalysis.data_checks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.check_corrupted_images" href="#EDA.DatasetAnalysis.data_checks.utils.check_corrupted_images">check_corrupted_images</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.check_duplicated_images" href="#EDA.DatasetAnalysis.data_checks.utils.check_duplicated_images">check_duplicated_images</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.check_images_extensions" href="#EDA.DatasetAnalysis.data_checks.utils.check_images_extensions">check_images_extensions</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.check_label_extensions" href="#EDA.DatasetAnalysis.data_checks.utils.check_label_extensions">check_label_extensions</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.check_unpaired_entities" href="#EDA.DatasetAnalysis.data_checks.utils.check_unpaired_entities">check_unpaired_entities</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.compute_kernel" href="#EDA.DatasetAnalysis.data_checks.utils.compute_kernel">compute_kernel</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.get_images_shapes" href="#EDA.DatasetAnalysis.data_checks.utils.get_images_shapes">get_images_shapes</a></code></li>
<li><code><a title="EDA.DatasetAnalysis.data_checks.utils.parallel_check_duplicated_images" href="#EDA.DatasetAnalysis.data_checks.utils.parallel_check_duplicated_images">parallel_check_duplicated_images</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>